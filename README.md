
# Hyrax and Kubernetes
How to run Hyrax using the docker container built and uploaded to DockerHub using Kubernetes.
This is specific to OSX, but I believe it could be generalized to Linux easily.

This was generated by asking ChatGPT to provide an example of running Hyrax using Kubernetes.
I asked for the simplest runnable example and then added a bit more complexity. Here are two
of the responses. jhrg 12/13/25

-----

The **simplest** way on macOS is to use **Docker s built-in single-node Kubernetes** and deploy one pod with a 
Service. s a dead-simple path you can run end-to-end in minutes.

# 1) Prereqs (macOS)

* Install **Docker Desktop for Mac** and in [it] **Enable Kubernetes**.
* Install kubectl (Docker Desktop bundles it; otherwise: `brew install kubectl`).
* Confirm it works:

  ```bash
  kubectl version --client
  kubectl get nodes
  ```

> Prefer not to enable Kubernetes in Docker Desktop? Use **kind** instead (`brew install kind && kind create cluster`).
> Everything below still applies; with kind, swap the `Service` to `NodePort` or use `port-forward`.

# 2) Test your Hyrax image locally (optional but recommended)

Make sure the container runs on your machine first:

```bash
docker run --rm -p 8080:8080 <your-hyrax-image>
# then visit http://localhost:8080/
```

# 3) Minimal Kubernetes manifest

Save this as `hyrax.yaml`. It creates:

* a **Deployment** (1 replica)
* a **Service** you can **port-forward** to localhost

> Replace `<your-hyrax-image>` with your image name (e.g., `opendap/hyrax:latest` if [that's] what you use) and adjust ports 
> if your image uses something other than 8080.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: hyrax
spec:
  replicas: 1
  selector:
    matchLabels:
      app: hyrax
  template:
    metadata:
      labels:
        app: hyrax
    spec:
      containers:
        - name: hyrax
          image: <your-hyrax-image>
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 8080
          # Optional: basic health checks (tweak path if needed)
          readinessProbe:
            httpGet:
              path: /
              port: 8080
            initialDelaySeconds: 20
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /
              port: 8080
            initialDelaySeconds: 60
            periodSeconds: 20
---
apiVersion: v1
kind: Service
metadata:
  name: hyrax
spec:
  selector:
    app: hyrax
  ports:
    - name: http
      port: 8080
      targetPort: 8080
  type: ClusterIP
```

Apply it:

```bash
kubectl apply -f hyrax.yaml
kubectl get pods -w
```

# 4) Access it

Easiest is **port-forward**:

```bash
kubectl port-forward svc/hyrax 8080:8080
```

Now open: [http://localhost:8080/](http://localhost:8080/) (append your Hyrax path, e.g., `/`)

> Alternative: change the Service to `type: LoadBalancer` on Docker Desktop (it will assign a localhost port
> automatically), or `type: NodePort` and reach it on the node IP and nodePort. Port-forward is the least fuss.

# 5) (Optional) Wire S3/CMR creds & config

Create a secret for credentials:

```bash
kubectl create secret generic hyrax-aws \
  --from-literal=AWS_ACCESS_KEY_ID='<key>' \
  --from-literal=AWS_SECRET_ACCESS_KEY='<secret>' \
  --from-literal=AWS_REGION='us-east-1'
```

Mount them as environment variables (add under the container in the Deployment):

```yaml
envFrom:
  - secretRef:
      name: hyrax-aws
```

Mount config files (hyrax config, catalogs, etc.) via a ConfigMap or a small PersistentVolumeClaim if the image 
expects files on disk.

# 6) (Optional) Make it internet-reachable

* Install an ingress controller (e.g., `ingress-nginx`) and add an `Ingress` with a host like `hyrax.localtest.me`.
* For internal demo work, stick to `kubectl port-s simpler.

# 7) Scale when ready

```bash
kubectl scale deploy/hyrax --replicas=3
kubectl get pods -o wide
```

---

## Quick variants

* **Using kind** (instead of Docker Desktop K8s):

  ```bash
  kind create cluster
  # If your Hyrax image is local-only:
  kind load docker-image <your-hyrax-image>
  kubectl apply -f hyrax.yaml
  kubectl port-forward svc/hyrax 8080:8080
  ```
* **Service as NodePort** (handy for kind):

  ```yaml
  spec:
    type: NodePort
    ports:
      - name: http
        port: 8080
        targetPort: 8080
        nodePort: 30080
  ```

  Then browse: [http://localhost:30080/](http://localhost:30080/)

---

# A second pass...

Below is a **simple-but-production-shaped** setup you can drop in, with **ConfigMap + Secret + PVC + Ingress**. 
It’s written to be **Hyrax-image-agnostic** (you’ll just adjust a couple of paths/ports to match your container).

## What you’ll get

* `Deployment` (Hyrax pod)
* `Service` (internal)
* `ConfigMap` (Hyrax config files)
* `Secret` (AWS/CMR/etc)
* `PVC` (persistent storage for cache/data)
* `Ingress` (nice URL like `hyrax.localtest.me`)

---

# 0) One-time cluster setup (Docker Desktop Kubernetes)

### Install ingress-nginx

```bash
kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/cloud/deploy.yaml
kubectl -n ingress-nginx rollout status deploy/ingress-nginx-controller
```

### Pick a local hostname

Use `hyrax.localtest.me` (it resolves to 127.0.0.1 automatically—no hosts file needed).

---

# 1) Create a namespace

```bash
kubectl create namespace hyrax
```

---

# 2) Secrets (AWS, CMR, etc.)

Create `hyrax-secrets` (edit values as needed):

```bash
kubectl -n hyrax create secret generic hyrax-secrets \
  --from-literal=AWS_ACCESS_KEY_ID='REPLACE_ME' \
  --from-literal=AWS_SECRET_ACCESS_KEY='REPLACE_ME' \
  --from-literal=AWS_REGION='us-west-2' \
  --from-literal=CMR_TOKEN='REPLACE_ME'
```

> If you don’t need some of these, omit them.

---

# 3) ConfigMap (mount config files)

This example mounts a directory at `/etc/hyrax/`. Replace with whatever your image expects.

Create `hyrax-config.yaml`:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: hyrax-config
  namespace: hyrax
data:
  # Example placeholder files. Replace with real Hyrax config snippets.
  hyrax.conf: |
    # Example config file content
    # Put your Hyrax settings here
  catalogs.xml: |
    <catalogs>
      <!-- Put your catalogs here -->
    </catalogs>
```

Apply:

```bash
kubectl apply -f hyrax-config.yaml
```

---

# 4) Persistent storage (PVC)

This is for anything Hyrax should persist (cache, generated DMR++, logs, etc.)

Create `hyrax-pvc.yaml`:

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: hyrax-pvc
  namespace: hyrax
spec:
  accessModes: ["ReadWriteOnce"]
  resources:
    requests:
      storage: 10Gi
```

Apply:

```bash
kubectl apply -f hyrax-pvc.yaml
```

---

# 5) Deployment + Service + Ingress

Create `hyrax-app.yaml` (replace `IMAGE` and **containerPort** if needed):

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: hyrax
  namespace: hyrax
spec:
  replicas: 1
  selector:
    matchLabels:
      app: hyrax
  template:
    metadata:
      labels:
        app: hyrax
    spec:
      containers:
        - name: hyrax
          image: IMAGE_REPLACE_ME
          imagePullPolicy: IfNotPresent
          ports:
            - name: http
              containerPort: 8080

          # Mount config files
          volumeMounts:
            - name: hyrax-config
              mountPath: /etc/hyrax
              readOnly: true

            # Persistent storage for cache/data/etc.
            - name: hyrax-data
              mountPath: /var/hyrax

          # Bring in secrets as env vars
          envFrom:
            - secretRef:
                name: hyrax-secrets

          # Optional: helpful probes (adjust path if Hyrax serves something else)
          readinessProbe:
            httpGet:
              path: /
              port: 8080
            initialDelaySeconds: 20
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /
              port: 8080
            initialDelaySeconds: 60
            periodSeconds: 20

      volumes:
        - name: hyrax-config
          configMap:
            name: hyrax-config
        - name: hyrax-data
          persistentVolumeClaim:
            claimName: hyrax-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: hyrax
  namespace: hyrax
spec:
  selector:
    app: hyrax
  ports:
    - name: http
      port: 80
      targetPort: 8080
  type: ClusterIP
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: hyrax
  namespace: hyrax
  annotations:
    nginx.ingress.kubernetes.io/proxy-body-size: "0"
spec:
  ingressClassName: nginx
  rules:
    - host: hyrax.localtest.me
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: hyrax
                port:
                  number: 80
```

Apply:

```bash
kubectl apply -f hyrax-app.yaml
kubectl -n hyrax get pods -w
```

Then open:

* [http://hyrax.localtest.me/](http://hyrax.localtest.me/)

---

# 6) If your Hyrax image is only local (not in a registry)

If Kubernetes can’t pull your image, either:

* Tag/push it to a registry, **or**
* On Docker Desktop K8s, local images usually work if `imagePullPolicy: IfNotPresent` (as above). If it still tries to pull, ensure the image name matches exactly what `docker images` shows.

---

# 7) Common Hyrax tweaks you’ll likely want

### If Hyrax serves under a subpath (e.g., `/opendap`)

* Keep Ingress path `/` but make sure the app handles it, **or**
* Set ingress path to `/opendap` (and adjust probes).

### If Hyrax uses port 80/8009/8080/etc.

* Change `containerPort` and the Service’s `targetPort`.

### If Hyrax wants configs somewhere else

* Change `mountPath: /etc/hyrax` to the correct directory.
* If it needs specific filenames, match them in the ConfigMap keys.

---

## Quick “tell me what to change” checklist

In `hyrax-app.yaml`, you typically only must edit:

* `image: IMAGE_REPLACE_ME`
* `containerPort: 8080` (if not 8080)
* `mountPath` values (if your image expects config/data elsewhere)
* probe `path:` (if `/` isn’t a good health endpoint)

---

If you paste:

1. the `docker run ...` command you currently use for Hyrax **or**
2. the env vars / volume mounts you pass today,

…I’ll translate it **exactly** into the Deployment (correct paths, ports, and config mounts) so it works on the first apply.

